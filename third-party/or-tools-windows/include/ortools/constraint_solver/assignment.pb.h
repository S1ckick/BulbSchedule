// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/constraint_solver/assignment.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ortools_2fconstraint_5fsolver_2fassignment_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ortools_2fconstraint_5fsolver_2fassignment_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ortools_2fconstraint_5fsolver_2fassignment_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ortools_2fconstraint_5fsolver_2fassignment_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ortools_2fconstraint_5fsolver_2fassignment_2eproto;
namespace operations_research {
class AssignmentProto;
struct AssignmentProtoDefaultTypeInternal;
extern AssignmentProtoDefaultTypeInternal _AssignmentProto_default_instance_;
class IntVarAssignment;
struct IntVarAssignmentDefaultTypeInternal;
extern IntVarAssignmentDefaultTypeInternal _IntVarAssignment_default_instance_;
class IntervalVarAssignment;
struct IntervalVarAssignmentDefaultTypeInternal;
extern IntervalVarAssignmentDefaultTypeInternal _IntervalVarAssignment_default_instance_;
class SequenceVarAssignment;
struct SequenceVarAssignmentDefaultTypeInternal;
extern SequenceVarAssignmentDefaultTypeInternal _SequenceVarAssignment_default_instance_;
class WorkerInfo;
struct WorkerInfoDefaultTypeInternal;
extern WorkerInfoDefaultTypeInternal _WorkerInfo_default_instance_;
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> ::operations_research::AssignmentProto* Arena::CreateMaybeMessage<::operations_research::AssignmentProto>(Arena*);
template<> ::operations_research::IntVarAssignment* Arena::CreateMaybeMessage<::operations_research::IntVarAssignment>(Arena*);
template<> ::operations_research::IntervalVarAssignment* Arena::CreateMaybeMessage<::operations_research::IntervalVarAssignment>(Arena*);
template<> ::operations_research::SequenceVarAssignment* Arena::CreateMaybeMessage<::operations_research::SequenceVarAssignment>(Arena*);
template<> ::operations_research::WorkerInfo* Arena::CreateMaybeMessage<::operations_research::WorkerInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace operations_research {

// ===================================================================

class IntVarAssignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.IntVarAssignment) */ {
 public:
  inline IntVarAssignment() : IntVarAssignment(nullptr) {}
  ~IntVarAssignment() override;
  explicit PROTOBUF_CONSTEXPR IntVarAssignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntVarAssignment(const IntVarAssignment& from);
  IntVarAssignment(IntVarAssignment&& from) noexcept
    : IntVarAssignment() {
    *this = ::std::move(from);
  }

  inline IntVarAssignment& operator=(const IntVarAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntVarAssignment& operator=(IntVarAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntVarAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntVarAssignment* internal_default_instance() {
    return reinterpret_cast<const IntVarAssignment*>(
               &_IntVarAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IntVarAssignment& a, IntVarAssignment& b) {
    a.Swap(&b);
  }
  inline void Swap(IntVarAssignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntVarAssignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntVarAssignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntVarAssignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntVarAssignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntVarAssignment& from) {
    IntVarAssignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntVarAssignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.IntVarAssignment";
  }
  protected:
  explicit IntVarAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarIdFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
    kActiveFieldNumber = 4,
  };
  // string var_id = 1;
  void clear_var_id();
  const std::string& var_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_id();
  PROTOBUF_NODISCARD std::string* release_var_id();
  void set_allocated_var_id(std::string* var_id);
  private:
  const std::string& _internal_var_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_id(const std::string& value);
  std::string* _internal_mutable_var_id();
  public:

  // int64 min = 2;
  void clear_min();
  int64_t min() const;
  void set_min(int64_t value);
  private:
  int64_t _internal_min() const;
  void _internal_set_min(int64_t value);
  public:

  // int64 max = 3;
  void clear_max();
  int64_t max() const;
  void set_max(int64_t value);
  private:
  int64_t _internal_max() const;
  void _internal_set_max(int64_t value);
  public:

  // bool active = 4;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.IntVarAssignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_id_;
    int64_t min_;
    int64_t max_;
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fconstraint_5fsolver_2fassignment_2eproto;
};
// -------------------------------------------------------------------

class IntervalVarAssignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.IntervalVarAssignment) */ {
 public:
  inline IntervalVarAssignment() : IntervalVarAssignment(nullptr) {}
  ~IntervalVarAssignment() override;
  explicit PROTOBUF_CONSTEXPR IntervalVarAssignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntervalVarAssignment(const IntervalVarAssignment& from);
  IntervalVarAssignment(IntervalVarAssignment&& from) noexcept
    : IntervalVarAssignment() {
    *this = ::std::move(from);
  }

  inline IntervalVarAssignment& operator=(const IntervalVarAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntervalVarAssignment& operator=(IntervalVarAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntervalVarAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntervalVarAssignment* internal_default_instance() {
    return reinterpret_cast<const IntervalVarAssignment*>(
               &_IntervalVarAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntervalVarAssignment& a, IntervalVarAssignment& b) {
    a.Swap(&b);
  }
  inline void Swap(IntervalVarAssignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntervalVarAssignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntervalVarAssignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntervalVarAssignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntervalVarAssignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntervalVarAssignment& from) {
    IntervalVarAssignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntervalVarAssignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.IntervalVarAssignment";
  }
  protected:
  explicit IntervalVarAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarIdFieldNumber = 1,
    kStartMinFieldNumber = 2,
    kStartMaxFieldNumber = 3,
    kDurationMinFieldNumber = 4,
    kDurationMaxFieldNumber = 5,
    kEndMinFieldNumber = 6,
    kEndMaxFieldNumber = 7,
    kPerformedMinFieldNumber = 8,
    kPerformedMaxFieldNumber = 9,
    kActiveFieldNumber = 10,
  };
  // string var_id = 1;
  void clear_var_id();
  const std::string& var_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_id();
  PROTOBUF_NODISCARD std::string* release_var_id();
  void set_allocated_var_id(std::string* var_id);
  private:
  const std::string& _internal_var_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_id(const std::string& value);
  std::string* _internal_mutable_var_id();
  public:

  // int64 start_min = 2;
  void clear_start_min();
  int64_t start_min() const;
  void set_start_min(int64_t value);
  private:
  int64_t _internal_start_min() const;
  void _internal_set_start_min(int64_t value);
  public:

  // int64 start_max = 3;
  void clear_start_max();
  int64_t start_max() const;
  void set_start_max(int64_t value);
  private:
  int64_t _internal_start_max() const;
  void _internal_set_start_max(int64_t value);
  public:

  // int64 duration_min = 4;
  void clear_duration_min();
  int64_t duration_min() const;
  void set_duration_min(int64_t value);
  private:
  int64_t _internal_duration_min() const;
  void _internal_set_duration_min(int64_t value);
  public:

  // int64 duration_max = 5;
  void clear_duration_max();
  int64_t duration_max() const;
  void set_duration_max(int64_t value);
  private:
  int64_t _internal_duration_max() const;
  void _internal_set_duration_max(int64_t value);
  public:

  // int64 end_min = 6;
  void clear_end_min();
  int64_t end_min() const;
  void set_end_min(int64_t value);
  private:
  int64_t _internal_end_min() const;
  void _internal_set_end_min(int64_t value);
  public:

  // int64 end_max = 7;
  void clear_end_max();
  int64_t end_max() const;
  void set_end_max(int64_t value);
  private:
  int64_t _internal_end_max() const;
  void _internal_set_end_max(int64_t value);
  public:

  // int64 performed_min = 8;
  void clear_performed_min();
  int64_t performed_min() const;
  void set_performed_min(int64_t value);
  private:
  int64_t _internal_performed_min() const;
  void _internal_set_performed_min(int64_t value);
  public:

  // int64 performed_max = 9;
  void clear_performed_max();
  int64_t performed_max() const;
  void set_performed_max(int64_t value);
  private:
  int64_t _internal_performed_max() const;
  void _internal_set_performed_max(int64_t value);
  public:

  // bool active = 10;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.IntervalVarAssignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_id_;
    int64_t start_min_;
    int64_t start_max_;
    int64_t duration_min_;
    int64_t duration_max_;
    int64_t end_min_;
    int64_t end_max_;
    int64_t performed_min_;
    int64_t performed_max_;
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fconstraint_5fsolver_2fassignment_2eproto;
};
// -------------------------------------------------------------------

class SequenceVarAssignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.SequenceVarAssignment) */ {
 public:
  inline SequenceVarAssignment() : SequenceVarAssignment(nullptr) {}
  ~SequenceVarAssignment() override;
  explicit PROTOBUF_CONSTEXPR SequenceVarAssignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequenceVarAssignment(const SequenceVarAssignment& from);
  SequenceVarAssignment(SequenceVarAssignment&& from) noexcept
    : SequenceVarAssignment() {
    *this = ::std::move(from);
  }

  inline SequenceVarAssignment& operator=(const SequenceVarAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequenceVarAssignment& operator=(SequenceVarAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SequenceVarAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SequenceVarAssignment* internal_default_instance() {
    return reinterpret_cast<const SequenceVarAssignment*>(
               &_SequenceVarAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SequenceVarAssignment& a, SequenceVarAssignment& b) {
    a.Swap(&b);
  }
  inline void Swap(SequenceVarAssignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequenceVarAssignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SequenceVarAssignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SequenceVarAssignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SequenceVarAssignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SequenceVarAssignment& from) {
    SequenceVarAssignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequenceVarAssignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.SequenceVarAssignment";
  }
  protected:
  explicit SequenceVarAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForwardSequenceFieldNumber = 2,
    kBackwardSequenceFieldNumber = 3,
    kUnperformedFieldNumber = 4,
    kVarIdFieldNumber = 1,
    kActiveFieldNumber = 5,
  };
  // repeated int32 forward_sequence = 2;
  int forward_sequence_size() const;
  private:
  int _internal_forward_sequence_size() const;
  public:
  void clear_forward_sequence();
  private:
  int32_t _internal_forward_sequence(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_forward_sequence() const;
  void _internal_add_forward_sequence(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_forward_sequence();
  public:
  int32_t forward_sequence(int index) const;
  void set_forward_sequence(int index, int32_t value);
  void add_forward_sequence(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      forward_sequence() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_forward_sequence();

  // repeated int32 backward_sequence = 3;
  int backward_sequence_size() const;
  private:
  int _internal_backward_sequence_size() const;
  public:
  void clear_backward_sequence();
  private:
  int32_t _internal_backward_sequence(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_backward_sequence() const;
  void _internal_add_backward_sequence(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_backward_sequence();
  public:
  int32_t backward_sequence(int index) const;
  void set_backward_sequence(int index, int32_t value);
  void add_backward_sequence(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      backward_sequence() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_backward_sequence();

  // repeated int32 unperformed = 4;
  int unperformed_size() const;
  private:
  int _internal_unperformed_size() const;
  public:
  void clear_unperformed();
  private:
  int32_t _internal_unperformed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_unperformed() const;
  void _internal_add_unperformed(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_unperformed();
  public:
  int32_t unperformed(int index) const;
  void set_unperformed(int index, int32_t value);
  void add_unperformed(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      unperformed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_unperformed();

  // string var_id = 1;
  void clear_var_id();
  const std::string& var_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_id();
  PROTOBUF_NODISCARD std::string* release_var_id();
  void set_allocated_var_id(std::string* var_id);
  private:
  const std::string& _internal_var_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_id(const std::string& value);
  std::string* _internal_mutable_var_id();
  public:

  // bool active = 5;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.SequenceVarAssignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > forward_sequence_;
    mutable std::atomic<int> _forward_sequence_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > backward_sequence_;
    mutable std::atomic<int> _backward_sequence_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > unperformed_;
    mutable std::atomic<int> _unperformed_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_id_;
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fconstraint_5fsolver_2fassignment_2eproto;
};
// -------------------------------------------------------------------

class WorkerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.WorkerInfo) */ {
 public:
  inline WorkerInfo() : WorkerInfo(nullptr) {}
  ~WorkerInfo() override;
  explicit PROTOBUF_CONSTEXPR WorkerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerInfo(const WorkerInfo& from);
  WorkerInfo(WorkerInfo&& from) noexcept
    : WorkerInfo() {
    *this = ::std::move(from);
  }

  inline WorkerInfo& operator=(const WorkerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerInfo& operator=(WorkerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerInfo* internal_default_instance() {
    return reinterpret_cast<const WorkerInfo*>(
               &_WorkerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WorkerInfo& a, WorkerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkerInfo& from) {
    WorkerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.WorkerInfo";
  }
  protected:
  explicit WorkerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBnsFieldNumber = 2,
    kWorkerIdFieldNumber = 1,
  };
  // string bns = 2;
  void clear_bns();
  const std::string& bns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bns();
  PROTOBUF_NODISCARD std::string* release_bns();
  void set_allocated_bns(std::string* bns);
  private:
  const std::string& _internal_bns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bns(const std::string& value);
  std::string* _internal_mutable_bns();
  public:

  // int32 worker_id = 1;
  void clear_worker_id();
  int32_t worker_id() const;
  void set_worker_id(int32_t value);
  private:
  int32_t _internal_worker_id() const;
  void _internal_set_worker_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.WorkerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bns_;
    int32_t worker_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fconstraint_5fsolver_2fassignment_2eproto;
};
// -------------------------------------------------------------------

class AssignmentProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.AssignmentProto) */ {
 public:
  inline AssignmentProto() : AssignmentProto(nullptr) {}
  ~AssignmentProto() override;
  explicit PROTOBUF_CONSTEXPR AssignmentProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignmentProto(const AssignmentProto& from);
  AssignmentProto(AssignmentProto&& from) noexcept
    : AssignmentProto() {
    *this = ::std::move(from);
  }

  inline AssignmentProto& operator=(const AssignmentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignmentProto& operator=(AssignmentProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignmentProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignmentProto* internal_default_instance() {
    return reinterpret_cast<const AssignmentProto*>(
               &_AssignmentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AssignmentProto& a, AssignmentProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignmentProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignmentProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignmentProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignmentProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignmentProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssignmentProto& from) {
    AssignmentProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignmentProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.AssignmentProto";
  }
  protected:
  explicit AssignmentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntVarAssignmentFieldNumber = 1,
    kIntervalVarAssignmentFieldNumber = 2,
    kSequenceVarAssignmentFieldNumber = 6,
    kObjectiveFieldNumber = 3,
    kWorkerInfoFieldNumber = 4,
    kIsValidFieldNumber = 5,
  };
  // repeated .operations_research.IntVarAssignment int_var_assignment = 1;
  int int_var_assignment_size() const;
  private:
  int _internal_int_var_assignment_size() const;
  public:
  void clear_int_var_assignment();
  ::operations_research::IntVarAssignment* mutable_int_var_assignment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntVarAssignment >*
      mutable_int_var_assignment();
  private:
  const ::operations_research::IntVarAssignment& _internal_int_var_assignment(int index) const;
  ::operations_research::IntVarAssignment* _internal_add_int_var_assignment();
  public:
  const ::operations_research::IntVarAssignment& int_var_assignment(int index) const;
  ::operations_research::IntVarAssignment* add_int_var_assignment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntVarAssignment >&
      int_var_assignment() const;

  // repeated .operations_research.IntervalVarAssignment interval_var_assignment = 2;
  int interval_var_assignment_size() const;
  private:
  int _internal_interval_var_assignment_size() const;
  public:
  void clear_interval_var_assignment();
  ::operations_research::IntervalVarAssignment* mutable_interval_var_assignment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntervalVarAssignment >*
      mutable_interval_var_assignment();
  private:
  const ::operations_research::IntervalVarAssignment& _internal_interval_var_assignment(int index) const;
  ::operations_research::IntervalVarAssignment* _internal_add_interval_var_assignment();
  public:
  const ::operations_research::IntervalVarAssignment& interval_var_assignment(int index) const;
  ::operations_research::IntervalVarAssignment* add_interval_var_assignment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntervalVarAssignment >&
      interval_var_assignment() const;

  // repeated .operations_research.SequenceVarAssignment sequence_var_assignment = 6;
  int sequence_var_assignment_size() const;
  private:
  int _internal_sequence_var_assignment_size() const;
  public:
  void clear_sequence_var_assignment();
  ::operations_research::SequenceVarAssignment* mutable_sequence_var_assignment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::SequenceVarAssignment >*
      mutable_sequence_var_assignment();
  private:
  const ::operations_research::SequenceVarAssignment& _internal_sequence_var_assignment(int index) const;
  ::operations_research::SequenceVarAssignment* _internal_add_sequence_var_assignment();
  public:
  const ::operations_research::SequenceVarAssignment& sequence_var_assignment(int index) const;
  ::operations_research::SequenceVarAssignment* add_sequence_var_assignment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::SequenceVarAssignment >&
      sequence_var_assignment() const;

  // .operations_research.IntVarAssignment objective = 3;
  bool has_objective() const;
  private:
  bool _internal_has_objective() const;
  public:
  void clear_objective();
  const ::operations_research::IntVarAssignment& objective() const;
  PROTOBUF_NODISCARD ::operations_research::IntVarAssignment* release_objective();
  ::operations_research::IntVarAssignment* mutable_objective();
  void set_allocated_objective(::operations_research::IntVarAssignment* objective);
  private:
  const ::operations_research::IntVarAssignment& _internal_objective() const;
  ::operations_research::IntVarAssignment* _internal_mutable_objective();
  public:
  void unsafe_arena_set_allocated_objective(
      ::operations_research::IntVarAssignment* objective);
  ::operations_research::IntVarAssignment* unsafe_arena_release_objective();

  // .operations_research.WorkerInfo worker_info = 4;
  bool has_worker_info() const;
  private:
  bool _internal_has_worker_info() const;
  public:
  void clear_worker_info();
  const ::operations_research::WorkerInfo& worker_info() const;
  PROTOBUF_NODISCARD ::operations_research::WorkerInfo* release_worker_info();
  ::operations_research::WorkerInfo* mutable_worker_info();
  void set_allocated_worker_info(::operations_research::WorkerInfo* worker_info);
  private:
  const ::operations_research::WorkerInfo& _internal_worker_info() const;
  ::operations_research::WorkerInfo* _internal_mutable_worker_info();
  public:
  void unsafe_arena_set_allocated_worker_info(
      ::operations_research::WorkerInfo* worker_info);
  ::operations_research::WorkerInfo* unsafe_arena_release_worker_info();

  // bool is_valid = 5;
  void clear_is_valid();
  bool is_valid() const;
  void set_is_valid(bool value);
  private:
  bool _internal_is_valid() const;
  void _internal_set_is_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.AssignmentProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntVarAssignment > int_var_assignment_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntervalVarAssignment > interval_var_assignment_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::SequenceVarAssignment > sequence_var_assignment_;
    ::operations_research::IntVarAssignment* objective_;
    ::operations_research::WorkerInfo* worker_info_;
    bool is_valid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fconstraint_5fsolver_2fassignment_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IntVarAssignment

// string var_id = 1;
inline void IntVarAssignment::clear_var_id() {
  _impl_.var_id_.ClearToEmpty();
}
inline const std::string& IntVarAssignment::var_id() const {
  // @@protoc_insertion_point(field_get:operations_research.IntVarAssignment.var_id)
  return _internal_var_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IntVarAssignment::set_var_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.IntVarAssignment.var_id)
}
inline std::string* IntVarAssignment::mutable_var_id() {
  std::string* _s = _internal_mutable_var_id();
  // @@protoc_insertion_point(field_mutable:operations_research.IntVarAssignment.var_id)
  return _s;
}
inline const std::string& IntVarAssignment::_internal_var_id() const {
  return _impl_.var_id_.Get();
}
inline void IntVarAssignment::_internal_set_var_id(const std::string& value) {
  
  _impl_.var_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IntVarAssignment::_internal_mutable_var_id() {
  
  return _impl_.var_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IntVarAssignment::release_var_id() {
  // @@protoc_insertion_point(field_release:operations_research.IntVarAssignment.var_id)
  return _impl_.var_id_.Release();
}
inline void IntVarAssignment::set_allocated_var_id(std::string* var_id) {
  if (var_id != nullptr) {
    
  } else {
    
  }
  _impl_.var_id_.SetAllocated(var_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_id_.IsDefault()) {
    _impl_.var_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.IntVarAssignment.var_id)
}

// int64 min = 2;
inline void IntVarAssignment::clear_min() {
  _impl_.min_ = int64_t{0};
}
inline int64_t IntVarAssignment::_internal_min() const {
  return _impl_.min_;
}
inline int64_t IntVarAssignment::min() const {
  // @@protoc_insertion_point(field_get:operations_research.IntVarAssignment.min)
  return _internal_min();
}
inline void IntVarAssignment::_internal_set_min(int64_t value) {
  
  _impl_.min_ = value;
}
inline void IntVarAssignment::set_min(int64_t value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:operations_research.IntVarAssignment.min)
}

// int64 max = 3;
inline void IntVarAssignment::clear_max() {
  _impl_.max_ = int64_t{0};
}
inline int64_t IntVarAssignment::_internal_max() const {
  return _impl_.max_;
}
inline int64_t IntVarAssignment::max() const {
  // @@protoc_insertion_point(field_get:operations_research.IntVarAssignment.max)
  return _internal_max();
}
inline void IntVarAssignment::_internal_set_max(int64_t value) {
  
  _impl_.max_ = value;
}
inline void IntVarAssignment::set_max(int64_t value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:operations_research.IntVarAssignment.max)
}

// bool active = 4;
inline void IntVarAssignment::clear_active() {
  _impl_.active_ = false;
}
inline bool IntVarAssignment::_internal_active() const {
  return _impl_.active_;
}
inline bool IntVarAssignment::active() const {
  // @@protoc_insertion_point(field_get:operations_research.IntVarAssignment.active)
  return _internal_active();
}
inline void IntVarAssignment::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void IntVarAssignment::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:operations_research.IntVarAssignment.active)
}

// -------------------------------------------------------------------

// IntervalVarAssignment

// string var_id = 1;
inline void IntervalVarAssignment::clear_var_id() {
  _impl_.var_id_.ClearToEmpty();
}
inline const std::string& IntervalVarAssignment::var_id() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.var_id)
  return _internal_var_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IntervalVarAssignment::set_var_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.var_id)
}
inline std::string* IntervalVarAssignment::mutable_var_id() {
  std::string* _s = _internal_mutable_var_id();
  // @@protoc_insertion_point(field_mutable:operations_research.IntervalVarAssignment.var_id)
  return _s;
}
inline const std::string& IntervalVarAssignment::_internal_var_id() const {
  return _impl_.var_id_.Get();
}
inline void IntervalVarAssignment::_internal_set_var_id(const std::string& value) {
  
  _impl_.var_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IntervalVarAssignment::_internal_mutable_var_id() {
  
  return _impl_.var_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IntervalVarAssignment::release_var_id() {
  // @@protoc_insertion_point(field_release:operations_research.IntervalVarAssignment.var_id)
  return _impl_.var_id_.Release();
}
inline void IntervalVarAssignment::set_allocated_var_id(std::string* var_id) {
  if (var_id != nullptr) {
    
  } else {
    
  }
  _impl_.var_id_.SetAllocated(var_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_id_.IsDefault()) {
    _impl_.var_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.IntervalVarAssignment.var_id)
}

// int64 start_min = 2;
inline void IntervalVarAssignment::clear_start_min() {
  _impl_.start_min_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_start_min() const {
  return _impl_.start_min_;
}
inline int64_t IntervalVarAssignment::start_min() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.start_min)
  return _internal_start_min();
}
inline void IntervalVarAssignment::_internal_set_start_min(int64_t value) {
  
  _impl_.start_min_ = value;
}
inline void IntervalVarAssignment::set_start_min(int64_t value) {
  _internal_set_start_min(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.start_min)
}

// int64 start_max = 3;
inline void IntervalVarAssignment::clear_start_max() {
  _impl_.start_max_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_start_max() const {
  return _impl_.start_max_;
}
inline int64_t IntervalVarAssignment::start_max() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.start_max)
  return _internal_start_max();
}
inline void IntervalVarAssignment::_internal_set_start_max(int64_t value) {
  
  _impl_.start_max_ = value;
}
inline void IntervalVarAssignment::set_start_max(int64_t value) {
  _internal_set_start_max(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.start_max)
}

// int64 duration_min = 4;
inline void IntervalVarAssignment::clear_duration_min() {
  _impl_.duration_min_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_duration_min() const {
  return _impl_.duration_min_;
}
inline int64_t IntervalVarAssignment::duration_min() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.duration_min)
  return _internal_duration_min();
}
inline void IntervalVarAssignment::_internal_set_duration_min(int64_t value) {
  
  _impl_.duration_min_ = value;
}
inline void IntervalVarAssignment::set_duration_min(int64_t value) {
  _internal_set_duration_min(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.duration_min)
}

// int64 duration_max = 5;
inline void IntervalVarAssignment::clear_duration_max() {
  _impl_.duration_max_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_duration_max() const {
  return _impl_.duration_max_;
}
inline int64_t IntervalVarAssignment::duration_max() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.duration_max)
  return _internal_duration_max();
}
inline void IntervalVarAssignment::_internal_set_duration_max(int64_t value) {
  
  _impl_.duration_max_ = value;
}
inline void IntervalVarAssignment::set_duration_max(int64_t value) {
  _internal_set_duration_max(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.duration_max)
}

// int64 end_min = 6;
inline void IntervalVarAssignment::clear_end_min() {
  _impl_.end_min_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_end_min() const {
  return _impl_.end_min_;
}
inline int64_t IntervalVarAssignment::end_min() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.end_min)
  return _internal_end_min();
}
inline void IntervalVarAssignment::_internal_set_end_min(int64_t value) {
  
  _impl_.end_min_ = value;
}
inline void IntervalVarAssignment::set_end_min(int64_t value) {
  _internal_set_end_min(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.end_min)
}

// int64 end_max = 7;
inline void IntervalVarAssignment::clear_end_max() {
  _impl_.end_max_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_end_max() const {
  return _impl_.end_max_;
}
inline int64_t IntervalVarAssignment::end_max() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.end_max)
  return _internal_end_max();
}
inline void IntervalVarAssignment::_internal_set_end_max(int64_t value) {
  
  _impl_.end_max_ = value;
}
inline void IntervalVarAssignment::set_end_max(int64_t value) {
  _internal_set_end_max(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.end_max)
}

// int64 performed_min = 8;
inline void IntervalVarAssignment::clear_performed_min() {
  _impl_.performed_min_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_performed_min() const {
  return _impl_.performed_min_;
}
inline int64_t IntervalVarAssignment::performed_min() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.performed_min)
  return _internal_performed_min();
}
inline void IntervalVarAssignment::_internal_set_performed_min(int64_t value) {
  
  _impl_.performed_min_ = value;
}
inline void IntervalVarAssignment::set_performed_min(int64_t value) {
  _internal_set_performed_min(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.performed_min)
}

// int64 performed_max = 9;
inline void IntervalVarAssignment::clear_performed_max() {
  _impl_.performed_max_ = int64_t{0};
}
inline int64_t IntervalVarAssignment::_internal_performed_max() const {
  return _impl_.performed_max_;
}
inline int64_t IntervalVarAssignment::performed_max() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.performed_max)
  return _internal_performed_max();
}
inline void IntervalVarAssignment::_internal_set_performed_max(int64_t value) {
  
  _impl_.performed_max_ = value;
}
inline void IntervalVarAssignment::set_performed_max(int64_t value) {
  _internal_set_performed_max(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.performed_max)
}

// bool active = 10;
inline void IntervalVarAssignment::clear_active() {
  _impl_.active_ = false;
}
inline bool IntervalVarAssignment::_internal_active() const {
  return _impl_.active_;
}
inline bool IntervalVarAssignment::active() const {
  // @@protoc_insertion_point(field_get:operations_research.IntervalVarAssignment.active)
  return _internal_active();
}
inline void IntervalVarAssignment::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void IntervalVarAssignment::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:operations_research.IntervalVarAssignment.active)
}

// -------------------------------------------------------------------

// SequenceVarAssignment

// string var_id = 1;
inline void SequenceVarAssignment::clear_var_id() {
  _impl_.var_id_.ClearToEmpty();
}
inline const std::string& SequenceVarAssignment::var_id() const {
  // @@protoc_insertion_point(field_get:operations_research.SequenceVarAssignment.var_id)
  return _internal_var_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SequenceVarAssignment::set_var_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.SequenceVarAssignment.var_id)
}
inline std::string* SequenceVarAssignment::mutable_var_id() {
  std::string* _s = _internal_mutable_var_id();
  // @@protoc_insertion_point(field_mutable:operations_research.SequenceVarAssignment.var_id)
  return _s;
}
inline const std::string& SequenceVarAssignment::_internal_var_id() const {
  return _impl_.var_id_.Get();
}
inline void SequenceVarAssignment::_internal_set_var_id(const std::string& value) {
  
  _impl_.var_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SequenceVarAssignment::_internal_mutable_var_id() {
  
  return _impl_.var_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SequenceVarAssignment::release_var_id() {
  // @@protoc_insertion_point(field_release:operations_research.SequenceVarAssignment.var_id)
  return _impl_.var_id_.Release();
}
inline void SequenceVarAssignment::set_allocated_var_id(std::string* var_id) {
  if (var_id != nullptr) {
    
  } else {
    
  }
  _impl_.var_id_.SetAllocated(var_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_id_.IsDefault()) {
    _impl_.var_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.SequenceVarAssignment.var_id)
}

// repeated int32 forward_sequence = 2;
inline int SequenceVarAssignment::_internal_forward_sequence_size() const {
  return _impl_.forward_sequence_.size();
}
inline int SequenceVarAssignment::forward_sequence_size() const {
  return _internal_forward_sequence_size();
}
inline void SequenceVarAssignment::clear_forward_sequence() {
  _impl_.forward_sequence_.Clear();
}
inline int32_t SequenceVarAssignment::_internal_forward_sequence(int index) const {
  return _impl_.forward_sequence_.Get(index);
}
inline int32_t SequenceVarAssignment::forward_sequence(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.SequenceVarAssignment.forward_sequence)
  return _internal_forward_sequence(index);
}
inline void SequenceVarAssignment::set_forward_sequence(int index, int32_t value) {
  _impl_.forward_sequence_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.SequenceVarAssignment.forward_sequence)
}
inline void SequenceVarAssignment::_internal_add_forward_sequence(int32_t value) {
  _impl_.forward_sequence_.Add(value);
}
inline void SequenceVarAssignment::add_forward_sequence(int32_t value) {
  _internal_add_forward_sequence(value);
  // @@protoc_insertion_point(field_add:operations_research.SequenceVarAssignment.forward_sequence)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SequenceVarAssignment::_internal_forward_sequence() const {
  return _impl_.forward_sequence_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SequenceVarAssignment::forward_sequence() const {
  // @@protoc_insertion_point(field_list:operations_research.SequenceVarAssignment.forward_sequence)
  return _internal_forward_sequence();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SequenceVarAssignment::_internal_mutable_forward_sequence() {
  return &_impl_.forward_sequence_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SequenceVarAssignment::mutable_forward_sequence() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.SequenceVarAssignment.forward_sequence)
  return _internal_mutable_forward_sequence();
}

// repeated int32 backward_sequence = 3;
inline int SequenceVarAssignment::_internal_backward_sequence_size() const {
  return _impl_.backward_sequence_.size();
}
inline int SequenceVarAssignment::backward_sequence_size() const {
  return _internal_backward_sequence_size();
}
inline void SequenceVarAssignment::clear_backward_sequence() {
  _impl_.backward_sequence_.Clear();
}
inline int32_t SequenceVarAssignment::_internal_backward_sequence(int index) const {
  return _impl_.backward_sequence_.Get(index);
}
inline int32_t SequenceVarAssignment::backward_sequence(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.SequenceVarAssignment.backward_sequence)
  return _internal_backward_sequence(index);
}
inline void SequenceVarAssignment::set_backward_sequence(int index, int32_t value) {
  _impl_.backward_sequence_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.SequenceVarAssignment.backward_sequence)
}
inline void SequenceVarAssignment::_internal_add_backward_sequence(int32_t value) {
  _impl_.backward_sequence_.Add(value);
}
inline void SequenceVarAssignment::add_backward_sequence(int32_t value) {
  _internal_add_backward_sequence(value);
  // @@protoc_insertion_point(field_add:operations_research.SequenceVarAssignment.backward_sequence)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SequenceVarAssignment::_internal_backward_sequence() const {
  return _impl_.backward_sequence_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SequenceVarAssignment::backward_sequence() const {
  // @@protoc_insertion_point(field_list:operations_research.SequenceVarAssignment.backward_sequence)
  return _internal_backward_sequence();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SequenceVarAssignment::_internal_mutable_backward_sequence() {
  return &_impl_.backward_sequence_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SequenceVarAssignment::mutable_backward_sequence() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.SequenceVarAssignment.backward_sequence)
  return _internal_mutable_backward_sequence();
}

// repeated int32 unperformed = 4;
inline int SequenceVarAssignment::_internal_unperformed_size() const {
  return _impl_.unperformed_.size();
}
inline int SequenceVarAssignment::unperformed_size() const {
  return _internal_unperformed_size();
}
inline void SequenceVarAssignment::clear_unperformed() {
  _impl_.unperformed_.Clear();
}
inline int32_t SequenceVarAssignment::_internal_unperformed(int index) const {
  return _impl_.unperformed_.Get(index);
}
inline int32_t SequenceVarAssignment::unperformed(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.SequenceVarAssignment.unperformed)
  return _internal_unperformed(index);
}
inline void SequenceVarAssignment::set_unperformed(int index, int32_t value) {
  _impl_.unperformed_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.SequenceVarAssignment.unperformed)
}
inline void SequenceVarAssignment::_internal_add_unperformed(int32_t value) {
  _impl_.unperformed_.Add(value);
}
inline void SequenceVarAssignment::add_unperformed(int32_t value) {
  _internal_add_unperformed(value);
  // @@protoc_insertion_point(field_add:operations_research.SequenceVarAssignment.unperformed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SequenceVarAssignment::_internal_unperformed() const {
  return _impl_.unperformed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SequenceVarAssignment::unperformed() const {
  // @@protoc_insertion_point(field_list:operations_research.SequenceVarAssignment.unperformed)
  return _internal_unperformed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SequenceVarAssignment::_internal_mutable_unperformed() {
  return &_impl_.unperformed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SequenceVarAssignment::mutable_unperformed() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.SequenceVarAssignment.unperformed)
  return _internal_mutable_unperformed();
}

// bool active = 5;
inline void SequenceVarAssignment::clear_active() {
  _impl_.active_ = false;
}
inline bool SequenceVarAssignment::_internal_active() const {
  return _impl_.active_;
}
inline bool SequenceVarAssignment::active() const {
  // @@protoc_insertion_point(field_get:operations_research.SequenceVarAssignment.active)
  return _internal_active();
}
inline void SequenceVarAssignment::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void SequenceVarAssignment::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:operations_research.SequenceVarAssignment.active)
}

// -------------------------------------------------------------------

// WorkerInfo

// int32 worker_id = 1;
inline void WorkerInfo::clear_worker_id() {
  _impl_.worker_id_ = 0;
}
inline int32_t WorkerInfo::_internal_worker_id() const {
  return _impl_.worker_id_;
}
inline int32_t WorkerInfo::worker_id() const {
  // @@protoc_insertion_point(field_get:operations_research.WorkerInfo.worker_id)
  return _internal_worker_id();
}
inline void WorkerInfo::_internal_set_worker_id(int32_t value) {
  
  _impl_.worker_id_ = value;
}
inline void WorkerInfo::set_worker_id(int32_t value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:operations_research.WorkerInfo.worker_id)
}

// string bns = 2;
inline void WorkerInfo::clear_bns() {
  _impl_.bns_.ClearToEmpty();
}
inline const std::string& WorkerInfo::bns() const {
  // @@protoc_insertion_point(field_get:operations_research.WorkerInfo.bns)
  return _internal_bns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerInfo::set_bns(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bns_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.WorkerInfo.bns)
}
inline std::string* WorkerInfo::mutable_bns() {
  std::string* _s = _internal_mutable_bns();
  // @@protoc_insertion_point(field_mutable:operations_research.WorkerInfo.bns)
  return _s;
}
inline const std::string& WorkerInfo::_internal_bns() const {
  return _impl_.bns_.Get();
}
inline void WorkerInfo::_internal_set_bns(const std::string& value) {
  
  _impl_.bns_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkerInfo::_internal_mutable_bns() {
  
  return _impl_.bns_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkerInfo::release_bns() {
  // @@protoc_insertion_point(field_release:operations_research.WorkerInfo.bns)
  return _impl_.bns_.Release();
}
inline void WorkerInfo::set_allocated_bns(std::string* bns) {
  if (bns != nullptr) {
    
  } else {
    
  }
  _impl_.bns_.SetAllocated(bns, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bns_.IsDefault()) {
    _impl_.bns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.WorkerInfo.bns)
}

// -------------------------------------------------------------------

// AssignmentProto

// repeated .operations_research.IntVarAssignment int_var_assignment = 1;
inline int AssignmentProto::_internal_int_var_assignment_size() const {
  return _impl_.int_var_assignment_.size();
}
inline int AssignmentProto::int_var_assignment_size() const {
  return _internal_int_var_assignment_size();
}
inline void AssignmentProto::clear_int_var_assignment() {
  _impl_.int_var_assignment_.Clear();
}
inline ::operations_research::IntVarAssignment* AssignmentProto::mutable_int_var_assignment(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.AssignmentProto.int_var_assignment)
  return _impl_.int_var_assignment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntVarAssignment >*
AssignmentProto::mutable_int_var_assignment() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.AssignmentProto.int_var_assignment)
  return &_impl_.int_var_assignment_;
}
inline const ::operations_research::IntVarAssignment& AssignmentProto::_internal_int_var_assignment(int index) const {
  return _impl_.int_var_assignment_.Get(index);
}
inline const ::operations_research::IntVarAssignment& AssignmentProto::int_var_assignment(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.AssignmentProto.int_var_assignment)
  return _internal_int_var_assignment(index);
}
inline ::operations_research::IntVarAssignment* AssignmentProto::_internal_add_int_var_assignment() {
  return _impl_.int_var_assignment_.Add();
}
inline ::operations_research::IntVarAssignment* AssignmentProto::add_int_var_assignment() {
  ::operations_research::IntVarAssignment* _add = _internal_add_int_var_assignment();
  // @@protoc_insertion_point(field_add:operations_research.AssignmentProto.int_var_assignment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntVarAssignment >&
AssignmentProto::int_var_assignment() const {
  // @@protoc_insertion_point(field_list:operations_research.AssignmentProto.int_var_assignment)
  return _impl_.int_var_assignment_;
}

// repeated .operations_research.IntervalVarAssignment interval_var_assignment = 2;
inline int AssignmentProto::_internal_interval_var_assignment_size() const {
  return _impl_.interval_var_assignment_.size();
}
inline int AssignmentProto::interval_var_assignment_size() const {
  return _internal_interval_var_assignment_size();
}
inline void AssignmentProto::clear_interval_var_assignment() {
  _impl_.interval_var_assignment_.Clear();
}
inline ::operations_research::IntervalVarAssignment* AssignmentProto::mutable_interval_var_assignment(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.AssignmentProto.interval_var_assignment)
  return _impl_.interval_var_assignment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntervalVarAssignment >*
AssignmentProto::mutable_interval_var_assignment() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.AssignmentProto.interval_var_assignment)
  return &_impl_.interval_var_assignment_;
}
inline const ::operations_research::IntervalVarAssignment& AssignmentProto::_internal_interval_var_assignment(int index) const {
  return _impl_.interval_var_assignment_.Get(index);
}
inline const ::operations_research::IntervalVarAssignment& AssignmentProto::interval_var_assignment(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.AssignmentProto.interval_var_assignment)
  return _internal_interval_var_assignment(index);
}
inline ::operations_research::IntervalVarAssignment* AssignmentProto::_internal_add_interval_var_assignment() {
  return _impl_.interval_var_assignment_.Add();
}
inline ::operations_research::IntervalVarAssignment* AssignmentProto::add_interval_var_assignment() {
  ::operations_research::IntervalVarAssignment* _add = _internal_add_interval_var_assignment();
  // @@protoc_insertion_point(field_add:operations_research.AssignmentProto.interval_var_assignment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::IntervalVarAssignment >&
AssignmentProto::interval_var_assignment() const {
  // @@protoc_insertion_point(field_list:operations_research.AssignmentProto.interval_var_assignment)
  return _impl_.interval_var_assignment_;
}

// repeated .operations_research.SequenceVarAssignment sequence_var_assignment = 6;
inline int AssignmentProto::_internal_sequence_var_assignment_size() const {
  return _impl_.sequence_var_assignment_.size();
}
inline int AssignmentProto::sequence_var_assignment_size() const {
  return _internal_sequence_var_assignment_size();
}
inline void AssignmentProto::clear_sequence_var_assignment() {
  _impl_.sequence_var_assignment_.Clear();
}
inline ::operations_research::SequenceVarAssignment* AssignmentProto::mutable_sequence_var_assignment(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.AssignmentProto.sequence_var_assignment)
  return _impl_.sequence_var_assignment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::SequenceVarAssignment >*
AssignmentProto::mutable_sequence_var_assignment() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.AssignmentProto.sequence_var_assignment)
  return &_impl_.sequence_var_assignment_;
}
inline const ::operations_research::SequenceVarAssignment& AssignmentProto::_internal_sequence_var_assignment(int index) const {
  return _impl_.sequence_var_assignment_.Get(index);
}
inline const ::operations_research::SequenceVarAssignment& AssignmentProto::sequence_var_assignment(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.AssignmentProto.sequence_var_assignment)
  return _internal_sequence_var_assignment(index);
}
inline ::operations_research::SequenceVarAssignment* AssignmentProto::_internal_add_sequence_var_assignment() {
  return _impl_.sequence_var_assignment_.Add();
}
inline ::operations_research::SequenceVarAssignment* AssignmentProto::add_sequence_var_assignment() {
  ::operations_research::SequenceVarAssignment* _add = _internal_add_sequence_var_assignment();
  // @@protoc_insertion_point(field_add:operations_research.AssignmentProto.sequence_var_assignment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::SequenceVarAssignment >&
AssignmentProto::sequence_var_assignment() const {
  // @@protoc_insertion_point(field_list:operations_research.AssignmentProto.sequence_var_assignment)
  return _impl_.sequence_var_assignment_;
}

// .operations_research.IntVarAssignment objective = 3;
inline bool AssignmentProto::_internal_has_objective() const {
  return this != internal_default_instance() && _impl_.objective_ != nullptr;
}
inline bool AssignmentProto::has_objective() const {
  return _internal_has_objective();
}
inline void AssignmentProto::clear_objective() {
  if (GetArenaForAllocation() == nullptr && _impl_.objective_ != nullptr) {
    delete _impl_.objective_;
  }
  _impl_.objective_ = nullptr;
}
inline const ::operations_research::IntVarAssignment& AssignmentProto::_internal_objective() const {
  const ::operations_research::IntVarAssignment* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::IntVarAssignment&>(
      ::operations_research::_IntVarAssignment_default_instance_);
}
inline const ::operations_research::IntVarAssignment& AssignmentProto::objective() const {
  // @@protoc_insertion_point(field_get:operations_research.AssignmentProto.objective)
  return _internal_objective();
}
inline void AssignmentProto::unsafe_arena_set_allocated_objective(
    ::operations_research::IntVarAssignment* objective) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = objective;
  if (objective) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.AssignmentProto.objective)
}
inline ::operations_research::IntVarAssignment* AssignmentProto::release_objective() {
  
  ::operations_research::IntVarAssignment* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::IntVarAssignment* AssignmentProto::unsafe_arena_release_objective() {
  // @@protoc_insertion_point(field_release:operations_research.AssignmentProto.objective)
  
  ::operations_research::IntVarAssignment* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::operations_research::IntVarAssignment* AssignmentProto::_internal_mutable_objective() {
  
  if (_impl_.objective_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::IntVarAssignment>(GetArenaForAllocation());
    _impl_.objective_ = p;
  }
  return _impl_.objective_;
}
inline ::operations_research::IntVarAssignment* AssignmentProto::mutable_objective() {
  ::operations_research::IntVarAssignment* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:operations_research.AssignmentProto.objective)
  return _msg;
}
inline void AssignmentProto::set_allocated_objective(::operations_research::IntVarAssignment* objective) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.objective_;
  }
  if (objective) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(objective);
    if (message_arena != submessage_arena) {
      objective = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objective, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objective_ = objective;
  // @@protoc_insertion_point(field_set_allocated:operations_research.AssignmentProto.objective)
}

// .operations_research.WorkerInfo worker_info = 4;
inline bool AssignmentProto::_internal_has_worker_info() const {
  return this != internal_default_instance() && _impl_.worker_info_ != nullptr;
}
inline bool AssignmentProto::has_worker_info() const {
  return _internal_has_worker_info();
}
inline void AssignmentProto::clear_worker_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.worker_info_ != nullptr) {
    delete _impl_.worker_info_;
  }
  _impl_.worker_info_ = nullptr;
}
inline const ::operations_research::WorkerInfo& AssignmentProto::_internal_worker_info() const {
  const ::operations_research::WorkerInfo* p = _impl_.worker_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::WorkerInfo&>(
      ::operations_research::_WorkerInfo_default_instance_);
}
inline const ::operations_research::WorkerInfo& AssignmentProto::worker_info() const {
  // @@protoc_insertion_point(field_get:operations_research.AssignmentProto.worker_info)
  return _internal_worker_info();
}
inline void AssignmentProto::unsafe_arena_set_allocated_worker_info(
    ::operations_research::WorkerInfo* worker_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.worker_info_);
  }
  _impl_.worker_info_ = worker_info;
  if (worker_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.AssignmentProto.worker_info)
}
inline ::operations_research::WorkerInfo* AssignmentProto::release_worker_info() {
  
  ::operations_research::WorkerInfo* temp = _impl_.worker_info_;
  _impl_.worker_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::WorkerInfo* AssignmentProto::unsafe_arena_release_worker_info() {
  // @@protoc_insertion_point(field_release:operations_research.AssignmentProto.worker_info)
  
  ::operations_research::WorkerInfo* temp = _impl_.worker_info_;
  _impl_.worker_info_ = nullptr;
  return temp;
}
inline ::operations_research::WorkerInfo* AssignmentProto::_internal_mutable_worker_info() {
  
  if (_impl_.worker_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::WorkerInfo>(GetArenaForAllocation());
    _impl_.worker_info_ = p;
  }
  return _impl_.worker_info_;
}
inline ::operations_research::WorkerInfo* AssignmentProto::mutable_worker_info() {
  ::operations_research::WorkerInfo* _msg = _internal_mutable_worker_info();
  // @@protoc_insertion_point(field_mutable:operations_research.AssignmentProto.worker_info)
  return _msg;
}
inline void AssignmentProto::set_allocated_worker_info(::operations_research::WorkerInfo* worker_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.worker_info_;
  }
  if (worker_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(worker_info);
    if (message_arena != submessage_arena) {
      worker_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, worker_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.worker_info_ = worker_info;
  // @@protoc_insertion_point(field_set_allocated:operations_research.AssignmentProto.worker_info)
}

// bool is_valid = 5;
inline void AssignmentProto::clear_is_valid() {
  _impl_.is_valid_ = false;
}
inline bool AssignmentProto::_internal_is_valid() const {
  return _impl_.is_valid_;
}
inline bool AssignmentProto::is_valid() const {
  // @@protoc_insertion_point(field_get:operations_research.AssignmentProto.is_valid)
  return _internal_is_valid();
}
inline void AssignmentProto::_internal_set_is_valid(bool value) {
  
  _impl_.is_valid_ = value;
}
inline void AssignmentProto::set_is_valid(bool value) {
  _internal_set_is_valid(value);
  // @@protoc_insertion_point(field_set:operations_research.AssignmentProto.is_valid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace operations_research

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ortools_2fconstraint_5fsolver_2fassignment_2eproto
